# 设计模式
>DesignPattern made by yanbowen

##六大设计原则  
###1.LiskovSubstitutionPrinciple  
>简称RSP原则；  
>建议接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化；  

#####单一职责原则优点：  
* 类的复杂性降低，实现什么职责都有清晰明确的定义；
* 可读性提高；
* 可维护性提高；
* 变更引起的风险降低；  

###2.OpenClosePrinciple  
>软件实体应该对扩展开放，对修改关闭  
  
###3.DependenceInversionPrinciple  
>简称DIP原则；  
  
#####依赖倒置原则定义：
* 高层模块不应该依赖低层模块，两者都应该依赖其抽象；
* 抽象不应该依赖细节；
* 细节应该依赖抽象。  
  
#####在Java语言中表现为：
* 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
* 接口或抽象类不依赖于实现类；
* 实现类依赖接口或抽象类；  

这也就是__“面向接口编程”__———OOD（Object-Oriented Design）  

#####软件实体：
* 项目或软件产品中按照一定的逻辑规则划分的模块，抽象类和方法；

- - -
##23种设计模式
###一、策略模式
>（策略模式使用的就是面向对象的继承和多态机制）  
  
#####1. 定义：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。  
#####2. 策略模式三个角色   
* Context封装角色：起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。
* Strategy抽象策略角色：策略、算法家族的抽象，通常为接口。  
* ConcreteStrategy具体策略角色：实现抽象策略中的操作。   
#####3. 优点   
* 算法可以自由切换
* 避免使用多重条件判断
* 扩展性良好（符合OPC原则）  
#####4. 缺点   
* 策略类数量增多  
* 所以的策略类都需要对外暴露  
#####5. 使用场景  
* 多个类只有在算法或行为上稍有不同的场景。  
* 算法需要自由切换的场景。
* 需要屏蔽算法规则的场景。  
  
###二、工厂模式
>（工厂模式中，抽象产品类Product负责定义产品的共性，实现对事物最抽象的定义；Creator为抽象创建类，也就是抽象工厂，具体如何创建产品类是由具体的实现工厂ConcreteCreator完成的。）  
  
#####1. 定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。  
#####2. 优点：  
* 良好的封装性，代码结构清晰，降低了模块之间的耦合性。
* 扩展性非常优秀，在新增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以完成___“拥抱变化”___。  
* 屏蔽产品类，不论产品类的实现如何变化，只要接口保持不变，系统中的上层模块就不要发生变化。
* 工厂模式是典型的解耦框架。符合__迪米特法则__，我不需要的就不要去交流；也符合__依赖倒置原则__，只依赖产品类的抽象；当然也符合__里氏替代原则__，使用子类替换产品父类。  
  
###三、观察者模式
>(观察者模式(Observer Pattern)也叫做发布订阅模式(Publish/subscribe))  
  
#####1. 定义：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所以依赖于它的对象都会得到通知并被自动更新。
* Subject被观察者：定义被观察者必须实现的职责，它必须能够动态地增加、取消观察者。它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者。
* Observer观察者：观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理。